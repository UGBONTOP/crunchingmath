<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Stealth Core v4</title>
    <style>
        body { background: #000; color: #111; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; }
        .ui-gate { opacity: 0.02; transition: 0.3s; padding: 20px; }
        .ui-gate:hover { opacity: 1; }
        input { background: #111; border: 1px solid #222; color: #0f0; padding: 10px; width: 220px; outline: none; }
        button { background: #222; color: #fff; border: 1px solid #333; padding: 10px; cursor: pointer; }
        #deep-space { width: 854px; height: 480px; background: #000; position: relative; }
    </style>
</head>
<body>

    <div class="ui-gate">
        <input type="text" id="v_src" placeholder="ID Only">
        <button id="v_bt">Initialize</button>
    </div>

    <div id="deep-space"></div>

    <script>
        (function() {
            const btn = document.getElementById('v_bt');
            const space = document.getElementById('deep-space');

            // Scrambled pieces for reconstruction
            const _m = ["ht", "tps", ":", "//", "www", ".you", "tube", "-no", "cookie", ".com", "/em", "bed/"];

            btn.addEventListener('click', () => {
                const id = document.getElementById('v_src').value.trim();
                if (id.length === 11) cloak(id);
            });

            function cloak(id) {
                space.innerHTML = '';
                
                // 1. NESTED SHADOW DOM (Double Layer Protection)
                // Layer 1
                const l1 = space.attachShadow({ mode: 'closed' });
                const container = document.createElement('div');
                l1.appendChild(container);
                
                // Layer 2 (The actual hideout)
                const l2 = container.attachShadow({ mode: 'closed' });

                const el = document.createElement('iframe'); // Using iframe but masking it
                el.style.width = '100%';
                el.style.height = '100%';
                el.style.border = 'none';
                el.setAttribute('referrerpolicy', 'no-referrer-when-downgrade');
                
                // 2. Fragmented URL Injection
                let u = "";
                _m.forEach(s => u += s);
                el.src = u + id + "?autoplay=1&modestbranding=1&rel=0";

                l2.appendChild(el);

                // 3. THE "DECEPTION" LOOP
                // This script runs every 100ms. If it finds a video tag with a "blob" src,
                // it tries to rename/hide the attribute from the extension's view.
                setInterval(() => {
                    try {
                        // We reach into the iframe and scramble the internal video tag's identity
                        const innerDoc = el.contentDocument || el.contentWindow.document;
                        const vids = innerDoc.getElementsByTagName('video');
                        
                        for (let v of vids) {
                            // Lie about what this is
                            if (v.hasAttribute('src')) {
                                const realSrc = v.src;
                                // We "hide" the src in a custom attribute that extensions don't track
                                v.setAttribute('data-ghost-src', realSrc); 
                                // We remove the 'class' that extensions use to find the player
                                v.removeAttribute('class');
                                v.className = "completely-generic-tag";
                            }
                        }
                    } catch(e) { 
                        // Cross-origin might block direct manipulation, 
                        // but the Shadow DOM layers usually handle that.
                    }
                }, 500);
            }
        })();
    </script>
</body>
</html>